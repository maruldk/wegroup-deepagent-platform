
import jsPDF from 'jspdf';
import html2canvas from 'html2canvas';
import * as XLSX from 'xlsx';
import { saveAs } from 'file-saver';

export interface ExportConfig {
  format: 'pdf' | 'excel' | 'csv' | 'png' | 'svg' | 'json';
  quality: 'low' | 'medium' | 'high';
  orientation?: 'portrait' | 'landscape';
  paperSize?: 'a4' | 'a3' | 'letter' | 'legal';
  includeCharts?: boolean;
  includeData?: boolean;
  compression?: boolean;
  metadata?: ExportMetadata;
}

export interface ExportMetadata {
  title: string;
  author: string;
  subject: string;
  creator: string;
  keywords: string[];
  createdAt: Date;
  customFields?: Record<string, any>;
}

export interface ExportResult {
  success: boolean;
  filename: string;
  size: number;
  downloadUrl?: string;
  error?: string;
}

export class ExportService {
  
  // Export dashboard to PDF
  static async exportDashboardToPDF(
    dashboardElement: HTMLElement,
    config: ExportConfig
  ): Promise<ExportResult> {
    try {
      const canvas = await html2canvas(dashboardElement, {
        scale: config.quality === 'high' ? 2 : config.quality === 'medium' ? 1.5 : 1,
        useCORS: true,
        allowTaint: true,
        backgroundColor: '#ffffff',
        logging: false,
        width: dashboardElement.scrollWidth,
        height: dashboardElement.scrollHeight
      });

      const imgData = canvas.toDataURL('image/png');
      const pdf = new jsPDF({
        orientation: config.orientation || 'portrait',
        unit: 'mm',
        format: config.paperSize || 'a4'
      });

      // Add metadata
      if (config.metadata) {
        pdf.setProperties({
          title: config.metadata.title,
          author: config.metadata.author,
          subject: config.metadata.subject,
          creator: config.metadata.creator,
          keywords: config.metadata.keywords.join(', ')
        });
      }

      // Calculate dimensions
      const pageWidth = pdf.internal.pageSize.getWidth();
      const pageHeight = pdf.internal.pageSize.getHeight();
      const imgWidth = canvas.width;
      const imgHeight = canvas.height;
      
      const ratio = Math.min(pageWidth / imgWidth, pageHeight / imgHeight);
      const finalWidth = imgWidth * ratio;
      const finalHeight = imgHeight * ratio;
      
      const x = (pageWidth - finalWidth) / 2;
      const y = (pageHeight - finalHeight) / 2;

      // Add header if metadata exists
      if (config.metadata) {
        pdf.setFontSize(16);
        pdf.text(config.metadata.title, pageWidth / 2, 20, { align: 'center' });
        pdf.setFontSize(10);
        pdf.text(`Generated on ${new Date().toLocaleDateString()}`, pageWidth / 2, 30, { align: 'center' });
      }

      // Add dashboard image
      pdf.addImage(imgData, 'PNG', x, y + 40, finalWidth, finalHeight);

      // Add footer
      pdf.setFontSize(8);
      pdf.text('Generated by weGROUP DeepAgent Platform', 10, pageHeight - 10);
      pdf.text(`Page 1`, pageWidth - 20, pageHeight - 10);

      const filename = `${config.metadata?.title || 'dashboard'}_${Date.now()}.pdf`;
      const blob = pdf.output('blob');
      
      saveAs(blob, filename);
      
      return {
        success: true,
        filename,
        size: blob.size
      };

    } catch (error) {
      console.error('PDF export failed:', error);
      return {
        success: false,
        filename: '',
        size: 0,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  // Export data to Excel
  static async exportDataToExcel(
    data: any[],
    config: ExportConfig,
    sheets?: { name: string; data: any[] }[]
  ): Promise<ExportResult> {
    try {
      const workbook = XLSX.utils.book_new();

      if (sheets && sheets.length > 0) {
        // Multiple sheets
        sheets.forEach(sheet => {
          const worksheet = XLSX.utils.json_to_sheet(sheet.data);
          this.applyExcelStyling(worksheet, config);
          XLSX.utils.book_append_sheet(workbook, worksheet, sheet.name);
        });
      } else {
        // Single sheet
        const worksheet = XLSX.utils.json_to_sheet(data);
        this.applyExcelStyling(worksheet, config);
        XLSX.utils.book_append_sheet(workbook, worksheet, 'Data');
      }

      // Add metadata
      if (config.metadata) {
        workbook.Props = {
          Title: config.metadata.title,
          Author: config.metadata.author,
          Subject: config.metadata.subject,
          CreatedDate: config.metadata.createdAt,
          Keywords: config.metadata.keywords.join(', ')
        };
      }

      const filename = `${config.metadata?.title || 'export'}_${Date.now()}.xlsx`;
      const buffer = XLSX.write(workbook, { 
        bookType: 'xlsx', 
        type: 'array',
        compression: config.compression 
      });
      
      const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
      saveAs(blob, filename);

      return {
        success: true,
        filename,
        size: blob.size
      };

    } catch (error) {
      console.error('Excel export failed:', error);
      return {
        success: false,
        filename: '',
        size: 0,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  // Export data to CSV
  static async exportDataToCSV(
    data: any[],
    config: ExportConfig
  ): Promise<ExportResult> {
    try {
      const worksheet = XLSX.utils.json_to_sheet(data);
      const csv = XLSX.utils.sheet_to_csv(worksheet);
      
      const filename = `${config.metadata?.title || 'export'}_${Date.now()}.csv`;
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      
      saveAs(blob, filename);

      return {
        success: true,
        filename,
        size: blob.size
      };

    } catch (error) {
      console.error('CSV export failed:', error);
      return {
        success: false,
        filename: '',
        size: 0,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  // Export element to PNG
  static async exportElementToPNG(
    element: HTMLElement,
    config: ExportConfig
  ): Promise<ExportResult> {
    try {
      const canvas = await html2canvas(element, {
        scale: config.quality === 'high' ? 3 : config.quality === 'medium' ? 2 : 1,
        useCORS: true,
        allowTaint: true,
        backgroundColor: '#ffffff',
        logging: false
      });

      const filename = `${config.metadata?.title || 'export'}_${Date.now()}.png`;
      
      canvas.toBlob((blob) => {
        if (blob) {
          saveAs(blob, filename);
        }
      }, 'image/png', config.quality === 'high' ? 1.0 : config.quality === 'medium' ? 0.8 : 0.6);

      return {
        success: true,
        filename,
        size: canvas.width * canvas.height * 4 // Rough estimate
      };

    } catch (error) {
      console.error('PNG export failed:', error);
      return {
        success: false,
        filename: '',
        size: 0,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  // Export dashboard configuration to JSON
  static async exportConfigToJSON(
    config: any,
    exportConfig: ExportConfig
  ): Promise<ExportResult> {
    try {
      const exportData = {
        metadata: {
          exportedAt: new Date().toISOString(),
          version: '2.2.0',
          exportType: 'dashboard_config',
          ...exportConfig.metadata
        },
        config
      };

      const jsonString = JSON.stringify(exportData, null, 2);
      const filename = `${exportConfig.metadata?.title || 'config'}_${Date.now()}.json`;
      const blob = new Blob([jsonString], { type: 'application/json' });
      
      saveAs(blob, filename);

      return {
        success: true,
        filename,
        size: blob.size
      };

    } catch (error) {
      console.error('JSON export failed:', error);
      return {
        success: false,
        filename: '',
        size: 0,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  // Bulk export multiple formats
  static async exportMultipleFormats(
    element: HTMLElement,
    data: any[],
    config: ExportConfig,
    formats: ExportConfig['format'][]
  ): Promise<ExportResult[]> {
    const results: ExportResult[] = [];

    for (const format of formats) {
      const formatConfig = { ...config, format };
      let result: ExportResult;

      switch (format) {
        case 'pdf':
          result = await this.exportDashboardToPDF(element, formatConfig);
          break;
        case 'excel':
          result = await this.exportDataToExcel(data, formatConfig);
          break;
        case 'csv':
          result = await this.exportDataToCSV(data, formatConfig);
          break;
        case 'png':
          result = await this.exportElementToPNG(element, formatConfig);
          break;
        case 'json':
          result = await this.exportConfigToJSON(data, formatConfig);
          break;
        default:
          result = {
            success: false,
            filename: '',
            size: 0,
            error: `Unsupported format: ${format}`
          };
      }

      results.push(result);
    }

    return results;
  }

  // Apply styling to Excel worksheet
  private static applyExcelStyling(worksheet: XLSX.WorkSheet, config: ExportConfig) {
    const range = XLSX.utils.decode_range(worksheet['!ref'] || 'A1');
    
    // Apply header styling
    for (let col = range.s.c; col <= range.e.c; col++) {
      const headerCell = XLSX.utils.encode_cell({ r: 0, c: col });
      if (worksheet[headerCell]) {
        worksheet[headerCell].s = {
          font: { bold: true, color: { rgb: 'FFFFFF' } },
          fill: { fgColor: { rgb: '366092' } },
          alignment: { horizontal: 'center' }
        };
      }
    }

    // Set column widths
    const colWidths = [];
    for (let col = range.s.c; col <= range.e.c; col++) {
      colWidths.push({ wch: 15 });
    }
    worksheet['!cols'] = colWidths;
  }

  // Get export format capabilities
  static getFormatCapabilities() {
    return {
      pdf: {
        name: 'PDF Document',
        supports: ['visual', 'charts', 'layout'],
        maxSize: '50MB',
        quality: ['low', 'medium', 'high']
      },
      excel: {
        name: 'Excel Spreadsheet',
        supports: ['data', 'formulas', 'multiple_sheets'],
        maxSize: '100MB',
        quality: ['medium']
      },
      csv: {
        name: 'CSV File',
        supports: ['data'],
        maxSize: '500MB',
        quality: ['medium']
      },
      png: {
        name: 'PNG Image',
        supports: ['visual', 'charts'],
        maxSize: '20MB',
        quality: ['low', 'medium', 'high']
      },
      json: {
        name: 'JSON Configuration',
        supports: ['config', 'metadata'],
        maxSize: '10MB',
        quality: ['medium']
      }
    };
  }

  // Estimate export size
  static estimateExportSize(
    element: HTMLElement,
    data: any[],
    format: ExportConfig['format'],
    quality: ExportConfig['quality']
  ): number {
    switch (format) {
      case 'pdf':
        const area = element.offsetWidth * element.offsetHeight;
        const qualityMultiplier = quality === 'high' ? 4 : quality === 'medium' ? 2 : 1;
        return Math.round(area * qualityMultiplier * 0.001); // Rough estimate in KB
      
      case 'excel':
        return data.length * Object.keys(data[0] || {}).length * 50; // Rough estimate in bytes
      
      case 'csv':
        return data.length * Object.keys(data[0] || {}).length * 20; // Rough estimate in bytes
      
      case 'png':
        const pngArea = element.offsetWidth * element.offsetHeight;
        const pngQualityMultiplier = quality === 'high' ? 8 : quality === 'medium' ? 4 : 2;
        return Math.round(pngArea * pngQualityMultiplier * 0.002); // Rough estimate in KB
      
      case 'json':
        return JSON.stringify(data).length; // Exact size in bytes
      
      default:
        return 0;
    }
  }
}

// Export utilities
export const exportUtils = {
  async exportData(
    element: HTMLElement,
    data: any[],
    config: ExportConfig
  ): Promise<ExportResult> {
    try {
      let result: ExportResult;

      switch (config.format) {
        case 'pdf':
          result = await ExportService.exportDashboardToPDF(element, config);
          break;
        case 'excel':
          result = await ExportService.exportDataToExcel(data, config);
          break;
        case 'csv':
          result = await ExportService.exportDataToCSV(data, config);
          break;
        case 'png':
          result = await ExportService.exportElementToPNG(element, config);
          break;
        case 'json':
          result = await ExportService.exportConfigToJSON(data, config);
          break;
        default:
          throw new Error(`Unsupported format: ${config.format}`);
      }

      return result;

    } catch (error) {
      console.error('Export failed:', error);
      return {
        success: false,
        filename: '',
        size: 0,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  },

  async exportMultiple(
    element: HTMLElement,
    data: any[],
    config: ExportConfig,
    formats: ExportConfig['format'][]
  ): Promise<ExportResult[]> {
    try {
      const results = await ExportService.exportMultipleFormats(element, data, config, formats);
      return results;
    } catch (error) {
      console.error('Multiple export failed:', error);
      return [];
    }
  },

  estimateSize(
    element: HTMLElement,
    data: any[],
    format: ExportConfig['format'],
    quality: ExportConfig['quality']
  ): number {
    return ExportService.estimateExportSize(element, data, format, quality);
  },

  getFormatCapabilities() {
    return ExportService.getFormatCapabilities();
  }
};
